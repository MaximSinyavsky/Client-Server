
## Клиент - серверная архитектура (Client-Server Architecture)
### Клиент - сервер
вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами. Фактически клиент и сервер - это программное обеспечение. Обычно эти программы расположены на разных вычислительных машинах и взаимодействуют между собой через вычислительную сеть посредством сетевых протоколов, но они могут быть расположены также и на одной машине. Программы-серверы ожидают от клиентских программ запросы и предоставляют им свои ресурсы в виде:
* данных (например, загрузка файлов посредством HTTP, FTP, BitTorrent, потоковое мультимедиа или работа с базами данных);
* сервисных функций (например, работа с электронной почтой, общение посредством систем мгновенного обмена сообщениями или просмотр web-страниц во всемирной паутине).

Поскольку одна программа-сервер может выполнять запросы от множества программ-клиентов, ее размещают на специально выделенной вычислительной машине, настроенной особым образом, как правило, совместно с другими программами-серверами, поэтому производительность этой машины должна быть высокой. Из-за особой роли такой машины в сети, специфики ее оборудования и программного обеспечения, её также называют сервером, а машины, выполняющие клиентские программы, соответственно, клиентами.

### Одноуровневая архитектура (1-Tier)

* Одноуровневая архитектура «клиент-сервер» (1-Tier) - такая, где все прикладные программы рассредоточены по рабочим станциям, которые обращаются к общему серверу баз данных или к общему файловому серверу. Никаких прикладных программ сервер при этом не исполняет, только предоставляет данные.
* В целом, такая архитектура очень надежна, однако, ей сложно управлять, поскольку в каждой рабочей станции данные будут присутствовать в разных вариантах. Поэтому возникает проблема их синхронизации на отдельных машинах. В общем, как можно видеть из рисунка, в этой архитектуре просматривается еще один уровень - базы данных, что дает повод во многих случаях называть её двухуровневой.

### Двухуровневая архитектура (2-Tier)

* К двухуровневой архитектуре «клиент-сервер» следует относить такую, в которой прикладные программы сосредоточены на сервере приложений (Application Server), например, сервере 1С или сервере CRM, а в рабочих станциях находятся программы-клиенты, которые предоставляют для пользователей интерфейс для работы с приложениями на общем сервере.

* Такая архитектура представляется наиболее логичной для архитектуры «клиент-сервер». В ней, однако, можно выделить два варианта. Когда общие данные хранятся на сервере, а логика их обработки и бизнес-данные хранятся на клиентской машине, то такая архитектура носит название “fat client thin server” (толстый клиент, тонкий сервер). Когда не только данные, но и логика их обработки и бизнес-данные хранятся на сервере, то это называется “thin client fat server” (тонкий клиент, толстый сервер). Такая архитектура послужила прообразом облачных вычислений (Cloud Computing).

### Трехуровневая архитектура (3-Tier)

* В трехуровневой архитектуре сервер баз данных, файловый сервер и другие представляют собой отдельный уровень, результаты работы которого использует сервер приложений. Логика данных и бизнес-логика находятся в сервере приложений. Все обращения клиентов к базе данных происходят через промежуточное программное обеспечение (middleware), которое находится на сервере приложений. Вследствие этого, повышается гибкость работы и производительность.

### Многоуровневая архитектура (N-Tier)

* В отдельный класс архитектуры «клиент-сервер» можно вынести многоуровневую архитектуру, в которой несколько серверов приложений используют результаты работы друг друга, а также данные от различных серверов баз данных, файловых серверов и других видов серверов.

* По сути, предыдущий вариант, трехуровневая архитектура - не более, чем частный случай многоуровневой архитектуры.

* Преимуществом многоуровневой архитектуры является гибкость предоставления услуг, которые могут являться комбинацией работы различных приложений серверов разных уровней и элементов этих приложений.
* Очевидным недостатком является сложность, многокомпонентность такой архитектуры.

## Монолин и микросервисы

Микросервисная архитектура или просто микросервисы - это особый метод разработки программных систем, который пытается сосредоточиться на создании однофункциональных модулей с четко определенными интерфейсами и операциями. Эта тенденция стала популярной в последние годы, поскольку предприятия стремятся стать более гибкими и перейти к DevOps и непрерывному тестированию.

Микросервисы имеют множество преимуществ для Agile- и DevOps-команд - как отмечает Мартин Фаулер, Netflix, eBay, Amazon, Twitter, PayPal и другие звезды технологий перешли от монолитной к микросервисной архитектуре. В отличие от микросервисов монолитное приложение строится как единая автономная единица. Это замедляет внесение изменений в приложение, поскольку влияет на всю систему. Модификация, внесенная в небольшой участок кода, может потребовать создания и развертывания совершенно новой версии программного обеспечения. Масштабирование определенных функций приложения также означает, что вам необходимо масштабировать все приложение. Микросервисы решают эти проблемы монолитных систем, будучи максимально модульными. В простейшей форме они помогают создать приложение в виде набора небольших служб, каждая из которых работает в своем собственном процессе и развертывается независимо. Эти сервисы могут быть написаны на разных языках программирования и могут использовать разные методы хранения данных. Хотя это приводит к разработке систем, которые являются масштабируемыми и гибкими, они нуждаются в динамическом преобразовании. Микросервисы часто подключаются через API и могут использовать многие из тех же инструментов и решений, которые выросли в экосистеме RESTful и веб-сервисов. Тестирование этих API может помочь проверить поток данных и информации во время развертывания микросервиса.

Точно так же, как не существует формального определения термина «микросервисы», нет и стандартной модели, которую вы увидите представленной в каждой системе, основанной на этом архитектурном стиле. Но вы можете ожидать, что большинство микросервисных систем будут иметь несколько примечательных характеристик:

* Мультикомпонентные: Программное обеспечение, созданное как микрослужбы, по определению может быть разбито на несколько составных служб. Почему? Таким образом каждую из этих служб можно развертывать, настраивать, а затем повторно развертывать независимо друг от друга без ущерба для целостности приложения. В результате вам может потребоваться изменить только одну или несколько отдельных служб вместо повторного развертывания целых приложений. Но у этого подхода есть свои недостатки, в том числе дорогостоящие удаленные вызовы (вместо вызовов внутри процесса), более грубые удаленные API и повышенная сложность при перераспределении обязанностей между компонентами;

* Созданы для бизнеса: Стиль микросервисов обычно организован вокруг бизнес-возможностей и приоритетов. В отличие от традиционного монолитного подхода к разработке, когда разные команды уделяют особое внимание, скажем, пользовательскому интерфейсу, базам данных, технологическим уровням или логике на стороне сервера, в микросервисной архитектуре используются кроссфункциональные команды. В обязанности каждой команды входит создание конкретных продуктов на основе одного или нескольких отдельных сервисов, взаимодействующих через шину сообщений. В микросервисах команда владеет продуктом всю жизнь, как в часто цитируемой максиме Amazon: “Вы создаете это, вы это запускаете”;

* Простая маршрутизация: Микросервисы действуют примерно так же, как классическая система UNIX: они получают запросы, обрабатывают их и генерируют соответствующий ответ. Это противоположно тому, как работают многие другие продукты, такие как ESB (Enterprise Service Buses), где используются высокотехнологичные системы для маршрутизации сообщений, хореографии и применения бизнес-правил. Можно сказать, что у микросервисов есть интеллектуальные конечные точки (endpoints), которые обрабатывают информацию и применяют логику, и тупые каналы (?dumb pipes), по которым информация течет;

* Децентрализованные: Поскольку микросервисы включают множество технологий и платформ, старые методы централизованного управления не являются оптимальными. Сообщество микросервисов предпочитает децентрализованное управление, потому что его разработчики стремятся создавать полезные инструменты, которые затем могут использоваться другими для решения тех же проблем. Как и децентрализованное управление, микросервисная архитектура также способствует децентрализованному управлению данными. Монолитные системы используют одну логическую базу данных для разных приложений. В микросервисном приложении каждая служба обычно управляет своей уникальной базой данных;

* Отказоустойчивые: Как всесторонне развитый ребенок, микросервисы созданы, чтобы справляться с ошибками. Поскольку несколько уникальных и разнообразных сервисов взаимодействуют друг с другом, вполне возможно, что сервис может выйти из строя по той или иной причине (например, когда поставщик недоступен). В этих случаях клиент должен позволить своим соседним службам работать, пока он отключается. Однако мониторинг микросервисов может помочь предотвратить риск сбоя. По понятным причинам это требование делает микросервисы более сложными по сравнению с архитектурой монолитных систем;

* Эволюционные: Архитектура микросервисов представляет собой эволюционный дизайн и, опять же, идеально подходит для эволюционирующих систем, в которых вы не можете полностью предвидеть типы устройств, которые однажды могут получить доступ к вашему приложению. , можно постепенно преобразовать в микросервисы, взаимодействующие с более старой монолитной архитектурой через API.

## Веб-страница, веб-сайт, веб-приложение, веб-сервис, веб-сервер















































































































































